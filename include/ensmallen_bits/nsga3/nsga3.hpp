/**
 * @file nsga3.hpp
 * @author Satyam Shukla
 *
 * NSGA-III is a multi-objective optimization algorithm, widely used in
 * many real-world applications. NSGA-III generates offsprings using
 * crossover and mutation and then selects the next generation according
 * to non-dominated-sorting and crowding distance comparison.The maintenance 
 * of diversity among population members in NSGA-III is aided by supplying and
 * adaptively updating a number of well-spread reference points.
 *
 * ensmallen is free software; you may redistribute it and/or modify it under
 * the terms of the 3-clause BSD license.  You should have received a copy of
 * the 3-clause BSD license along with ensmallen.  If not, see
 * http://www.opensource.org/licenses/BSD-3-Clause for more information.
 */

#ifndef ENSMALLEN_NSGA3_NSGA3_HPP
#define ENSMALLEN_NSGA3_NSGA3_HPP

namespace ens {

/**
 * NSGA-III (Non-dominated Sorting Genetic Algorithm - III) is a multi-objective
 * optimization algorithm. This class implements the NSGA-III algorithm.
 *
 * The algorithm works by generating a candidate population from a fixed
 * starting point. At each stage of optimization, a new population of children
 * is generated. This new population along with its predecessor is sorted using
 * non-domination as the metric. Following this, the population is further
 * segregated in fronts. A new population is generated from these fronts having
 * size equal to that of the starting population.
 *
 * During evolution, two parents are randomly chosen using binary tournament
 * selection. A pair of children are generated by crossing over these two
 * candidates followed by mutation.
 *
 * The best front (Pareto optimal) is returned by the Optimize() method.
 *
 * For more information, see the following:
 *
 * @code
 * @article{deb2013evolutionary,
 * title={An evolutionary many-objective optimization algorithm using reference-point-based nondominated sorting approach, part I: solving problems with box constraints},
 * author={Deb, Kalyanmoy and Jain, Himanshu},
 * journal={IEEE transactions on evolutionary computation},
 * volume={18},
 * number={4},
 * pages={577--601},
 * year={2013},
 * publisher={IEEE}
 * }
 * @endcode
 *
 * NSGA-III can optimize arbitrary multi-objective functions. For more details,
 * see the documentation on function types included with this distribution or
 * on the ensmallen website.
 */
template <typename MatType>
class NSGA3
{
 public:
  /**
   * Constructor for the NSGA3 optimizer.
   *
   * The default values provided over here are not necessarily suitable for a
   * given function. Therefore it is highly recommended to adjust the
   * parameters according to the problem.
   * 
   * @param referencePoints The reference points to be used.
   * @param populationSize The number of candidates in the population.
   *     This should be atleast 4 in size and a multiple of 4.
   * @param maxGenerations The maximum number of generations allowed for NSGA-II.
   * @param crossoverProb The probability that a crossover will occur.
   * @param mutationProb The probability that a mutation will occur.
   * @param mutationStrength The strength of the mutation.
   * @param epsilon The minimum difference required to distinguish between
   *     candidate solutions.
   * @param lowerBound Lower bound of the coordinates of the initial population.
   * @param upperBound Upper bound of the coordinates of the initial population.
   */
  NSGA3(const arma::Cube<MatType::elem_type>& referencePoints,
        const size_t populationSize = 100,
        const size_t maxGenerations = 2000,
        const double crossoverProb = 0.6,
        const double mutationProb = 0.3,
        const double mutationStrength = 1e-3, 
        const double epsilon = 1e-6,
        const arma::vec& lowerBound = arma::zeros(1, 1),
        const arma::vec& upperBound = arma::ones(1, 1));

  /**
   * Constructor for the NSGA3 optimizer. This constructor provides an overload
   * to use `lowerBound` and `upperBound` of type double.
   *
   * The default values provided over here are not necessarily suitable for a
   * given function. Therefore it is highly recommended to adjust the
   * parameters according to the problem.
   *
   * @param referencePoints The reference points to be used.
   * @param populationSize The number of candidates in the population.
   *     This should be atleast 4 in size and a multiple of 4.
   * @param maxGenerations The maximum number of generations allowed for NSGA-II.
   * @param crossoverProb The probability that a crossover will occur.
   * @param mutationProb The probability that a mutation will occur.
   * @param mutationStrength The strength of the mutation.
   * @param epsilon The minimum difference required to distinguish between
   *     candidate solutions.
   * @param lowerBound Lower bound of the coordinates of the initial population.
   * @param upperBound Upper bound of the coordinates of the initial population.
   */
  NSGA3(const arma::Cube<MatType::elem_type>& referencePoints,
        const size_t populationSize = 100,
        const size_t maxGenerations = 2000,
        const double crossoverProb = 0.6,
        const double mutationProb = 0.3,
        const double mutationStrength = 1e-3,
        const double epsilon = 1e-6,
        const double lowerBound = 0,
        const double upperBound = 1);

  /**
   * Optimize a set of objectives. The initial population is generated using the
   * starting point. The output is the best generated front.
   *
   * @tparam ArbitraryFunctionType std::tuple of multiple objectives.
   * @tparam CallbackTypes Types of callback functions.
   * @param objectives Vector of objective functions to optimize for.
   * @param iterate Starting point.
   * @param callbacks Callback functions.
   * @return MatType::elem_type The minimum of the accumulated sum over the
   *     objective values in the best front.
   */
  template<typename... ArbitraryFunctionType,
           typename... CallbackTypes>
 typename MatType::elem_type Optimize(
     std::tuple<ArbitraryFunctionType...>& objectives,
     MatType& iterate,
     CallbackTypes&&... callbacks);

  //! Get the population size.
  size_t PopulationSize() const { return populationSize; }
  //! Modify the population size.
  size_t& PopulationSize() { return populationSize; }

  //! Get the maximum number of generations.
  size_t MaxGenerations() const { return maxGenerations; }
  //! Modify the maximum number of generations.
  size_t& MaxGenerations() { return maxGenerations; }

  //! Get the crossover rate.
  double CrossoverRate() const { return crossoverProb; }
  //! Modify the crossover rate.
  double& CrossoverRate() { return crossoverProb; }

  //! Get the mutation probability.
  double MutationProbability() const { return mutationProb; }
  //! Modify the mutation probability.
  double& MutationProbability() { return mutationProb; }

  //! Get the mutation strength.
  double MutationStrength() const { return mutationStrength; }
  //! Modify the mutation strength.
  double& MutationStrength() { return mutationStrength; }

  //! Get the tolerance.
  double Epsilon() const { return epsilon; }
  //! Modify the tolerance.
  double& Epsilon() { return epsilon; }

  //! Get the reference points.
  const arma::Cube<MatType>& ReferencePoints() const { return referencePoints; }
  //! Modify the reference points.
  arma::Cube<MatType>& ReferencePoints() { return referencePoints; }

  //! Retrieve value of lowerBound.
  const arma::vec& LowerBound() const { return lowerBound; }
  //! Modify value of lowerBound.
  arma::vec& LowerBound() { return lowerBound; }

  //! Retrieve value of upperBound.
  const arma::vec& UpperBound() const { return upperBound; }
  //! Modify value of upperBound.
  arma::vec& UpperBound() { return upperBound; }

  //! Retrieve the Pareto optimal points in variable space. This returns an empty cube
  //! until `Optimize()` has been called.
  const arma::cube& ParetoSet() const { return paretoSet; }

  //! Retrieve the best front (the Pareto frontier). This returns an empty cube until
  //! `Optimize()` has been called.
  const arma::cube& ParetoFront() const { return paretoFront; }

  /**
   * Retrieve the best front (the Pareto frontier).  This returns an empty
   * vector until `Optimize()` has been called.  Note that this function is
   * deprecated and will be removed in ensmallen 3.x!  Use `ParetoFront()`
   * instead.
   */
  [[deprecated("use ParetoFront() instead")]] const std::vector<arma::mat>& Front()
  {
    if (rcFront.size() == 0)
    {
      // Match the old return format.
      for (size_t i = 0; i < paretoFront.n_slices; ++i)
      {
        rcFront.push_back(arma::mat(paretoFront.slice(i)));
      }
    }

    return rcFront;
  }

 private:
  /**
   * Evaluate objectives for the elite population.
   *
   * @tparam ArbitraryFunctionType std::tuple of multiple function types.
   * @tparam MatType Type of matrix to optimize.
   * @param population The elite population.
   * @param objectives The set of objectives.
   * @param calculatedObjectives Vector to store calculated objectives.
   */
  template<std::size_t I = 0,
           typename ColType = arma::Col<typename MatType::elem_type>,
           typename ...ArbitraryFunctionType>
  typename std::enable_if<I == sizeof...(ArbitraryFunctionType), void>::type
  EvaluateObjectives(std::vector<MatType>&,
                     std::tuple<ArbitraryFunctionType...>&,
                     std::vector<ColType>&);

  template<std::size_t I = 0,
           typename ColType = arma::Col<typename MatType::elem_type>,
           typename ...ArbitraryFunctionType>
  typename std::enable_if<I < sizeof...(ArbitraryFunctionType), void>::type
  EvaluateObjectives(std::vector<MatType>& population,
                     std::tuple<ArbitraryFunctionType...>& objectives,
                     std::vector<ColType>& calculatedObjectives);

  /**
   * Reproduce candidates from the elite population to generate a new
   * population.
   *
   * @tparam MatType Type of matrix to optimize.
   * @param population The elite population.
   * @param objectives The set of objectives.
   * @param lowerBound Lower bound of the coordinates of the initial population.
   * @param upperBound Upper bound of the coordinates of the initial population.
   */
  void BinaryTournamentSelection(std::vector<MatType>& population,
                                 const MatType& lowerBound,
                                 const MatType& upperBound);

  /**
   * Crossover two parents to create a pair of new children.
   *
   * @tparam MatType Type of matrix to optimize.
   * @param childA A newly generated candidate.
   * @param childB Another newly generated candidate.
   * @param parentA First parent from elite population.
   * @param parentB Second parent from elite population.
   */
  void Crossover(MatType& childA,
                 MatType& childB,
                 const MatType& parentA,
                 const MatType& parentB);

  /**
   * Mutate the coordinates for a candidate.
   *
   * @tparam MatType Type of matrix to optimize.
   * @param child The candidate whose coordinates are being modified.
   * @param objectives The set of objectives.
   * @param lowerBound Lower bound of the coordinates of the initial population.
   * @param upperBound Upper bound of the coordinates of the initial population.
   */
  void Mutate(MatType& child,
              const MatType& lowerBound,
              const MatType& upperBound);

  /**
   * Sort the candidate population using their domination count and the set of
   * dominated nodes.
   *
   * @tparam MatType Type of matrix to optimize.
   * @param fronts The population is sorted into these Pareto fronts. The first
   *     front is the best, the second worse and so on.
   * @param ranks The assigned ranks, used for crowding distance based sorting.
   * @param calculatedObjectives The previously calculated objectives.
   */
  template<typename ColType>
  void FastNonDominatedSort(
      std::vector<std::vector<size_t> >& fronts,
      std::vector<size_t>& ranks,
      std::vector<ColType>& calculatedObjectives);

  /**
   * Normalizes the front given the extreme points in the current front.
   *
   * @tparam The type of population datapoints.
   * @param calculatedObjectives The current population evaluated objectives.
   * @param normalization The normalizing vector.
   * @param front The previously generated Pareto front.
   * @param extreme The indexes of the extreme points in the front.
   */
  template<typename ColType>
  void NormalizeFront(std::vector<ColType>& calculatedObjectives,
                      ColType& normalization,
                      const std::vector<size_t>& front,
                      const arma::Row<size_t>& extreme);

  /**
   * Finding the indexes of the extreme points in the front.
   *  
   * @param indexes vector containing the slected indexes.
   * @param calculatedObjectives The current population objectives.
   * @param front The front of the current generation.
   */
  template<typename ColType>
  void FindExtremePoints(arma::Row<size_t>& indexes,
                         std::vector<ColType>& calculatedObjectives,
                         const std::vector<size_t>& front);
                        
  /**
   * Finding the distance of each point in the front from the line formed
   * by pointA and pointB.
   * 
   * @param distance The vector containing the distances of the points in the fron from the line.
   * @param calculatedObjectives Reference to the current population evaluated Objectives.
   * @param front The front of the current generation(indices of population).
   * @param pointA The first point on the line.
   * @param pointB The second point on the line.
   */
  template<typename ColType>
  void PointToLineDistance(arma::Row<typename MatType::elem_type>& distances,
                           std::vector<ColType>& calculatedObjectives,
                           const std::vector<size_t>& front,
                           const ColType& pointA,
                           const ColType& pointB);

  /**
   * Finding the point in the reference front associated with the members in
   * the given front and also stores the distance between the two points.
   * 
   * @param refIndex Vector containing the index of the point in the refrence directons associated.
   * @param dists Vector of distances from the corresponding point in the front to the associated reference direction.
   * @param calculatedObjectives The points of the currently generated population.
   * @param St The index of points belonging to the given front.
   */
  template <typename ColType>
  void Associate(arma::urowvec& refIndex,
                 arma::Row<typename MatType::elem_type>& dists,
                 const std::vector<ColType>& calculatedObjectives,
                 const std::vector<size_t>& St);

  /**
   * Find the niche count for each reference direction.
   * 
   * @param count The no. of points associated with each niche direction.
   * @param refIndex  Vector containing the index of the point in the reference 
   * directons associated.
   */
  void NicheCount(arma::Row<size_t>& count,
                  const arma::urowvec& refIndex);

  /**
   * The niche preserving operation to select the final points form the given front
   * aranges the front in descending order of priority for the top K points in the front.
   * 
   * @param K The no. of remaining points to select from the given front for the next population.
   * @param nicheCount The count of no. of points associated to each reference point in St.
   * @param refIndex The index of the rerference points associated with the in the given front.
   * @param dists The distances of th points in the front form their associated reference points line.
   * @param front The index of teh points within the population which are a part of the given front.
   * @param population The set St (selected points).
   */
  void Niching(size_t K,
               arma::Row<size_t>& nicheCount,
               const arma::urowvec& refIndex,
               const arma::Row<typename MatType::elem_type>& dists,
               const std::vector<size_t>& front,
               std::vector<size_t>& population);
  
  /**
   * Operator to check if one candidate Pareto-dominates the other.
   *
   * A candidate is said to dominate the other if it is at least as good as the
   * other candidate for all the objectives and there exists at least one
   * objective for which it is strictly better than the other candidate.
   *
   * @tparam MatType Type of matrix to optimize.
   * @param calculatedObjectives The previously calculated objectives.
   * @param candidateP The candidate being compared from the elite population.
   * @param candidateQ The candidate being compared against.
   * @return true if candidateP Pareto dominates candidateQ, otherwise, false.
   */
  template<typename ColType>
  bool Dominates(
      std::vector<ColType>& calculatedObjectives,
      size_t candidateP,
      size_t candidateQ);

  //! The number of objectives being optimised for.
  size_t numObjectives;

  //! The numbeer of variables used per objectives.
  size_t numVariables;

  //! The number of candidates in the population.
  size_t populationSize;

  //! Maximum number of generations before termination criteria is met.
  size_t maxGenerations;

  //! Probability that crossover will occur.
  double crossoverProb;

  //! Probability that mutation will occur.
  double mutationProb;

  //! Strength of the mutation.
  double mutationStrength;

  //! The tolerance for termination.
  double epsilon;

  //! Lower bound of the initial swarm.
  arma::vec lowerBound;

  //! Upper bound of the initial swarm.
  arma::vec upperBound;

  //! The set of all the Pareto optimal points.
  //! Stored after Optimize() is called.
  arma::cube paretoSet;

  //! The set of all the Pareto optimal objective vectors.
  //! Stored after Optimize() is called.
  arma::cube paretoFront;

  //! The reference points.
  arma::Cube<MatType> referencePoints;

  //! A different representation of the Pareto front, for reverse compatibility
  //! purposes.  This can be removed when ensmallen 3.x is released!  (Along
  //! with `Front()`.)  This is only populated when `Front()` is called.
  std::vector<arma::mat> rcFront;
};

} // namespace ens

// Include implementation.
#include "nsga3_impl.hpp"

#endif
